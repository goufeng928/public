# 文章_Unix运维_如何测试C11和C++11至C17和C++17标准的支持_GF_2023-04-01

**C语言 标准主要有以下几个版本**:

**K&R C**: 这是 C语言 的第一个标准, 由 Dennis Ritchie 和 Brian Kernighan 于 1978 年在《The C Programming Language》一书中定义。K&R C 标准包含了基本的语法, 数据类型, 运算符等, 但并不是完整的语言规范, 缺少了一些重要的特性, 例如函数原型, 结构体等。

**ANSI C**: 也称为 C89, 是由美国国家标准协会 (ANSI) 于 1983 年发布的一个标准。该标准定义了 C语言 的全部语法, 数据类型, 库函数等, 是 C语言 的第一个完整的规范。ANSI C 标准引入了一些新特性, 例如函数原型, void 类型, const 限定符等。

**C99**: 是 ISO/IEC 9899:1999 标准, 于 1999 年发布。C99 标准对 C语言 进行了大量的扩展和改进, 引入了很多新特性, 例如布尔类型, 复数类型, 变长数组, 标准宏等。C99 标准还修正了一些 C89/C90 标准中的错误和不足之处, 使得C语言更加完善和健壮。

**C11**: 是 ISO/IEC 9899:2011 标准, 于 2011 年发布。C11 标准在 C99 基础上进行了进一步的扩展和改进, 包括了一些新特性, 例如泛型宏, 多线程支持, _Static_assert 等。C11 标准对于一些早期 C标准 中存在的问题进行了修正, 使得 C语言 更加健壮和安全。

**C++ 标准自 C++ 的 ANSI/IS0 标准投用以来, 已进行过多次更新**:

**C++11: 发布时间为 2011年08月12日, 正式名称为 ISO/IEC 14882:2011**

C++11 对容器类的方法做了三项主要修改:

(1) 新增了右值引用, 可以给容器提供移动语义。

(2) 新增了模板类 initilizer_list, 因此可将 initilizer_list 作为参数的构造函数和赋值运算符。

(3) 新增了可变参数模板 (variadic template) 和函数参数包 (parameter pack), 可以提供就地创建 (emplacement) 方法。

**C++14: 发布时间为 2014年08月18日, 正式名称为 ISO/IEC 14882:2014**

C++14 为 C++11 的增量更新。主要是支持普通函数的返回类型推演, 泛型 lambda, 扩展的 lambda 捕获, 对 constexpr 函数限制的修订, constexpr 变量模板化等。

**C++17: 发布时间为 2017年12月06日, 正式名称为 ISO/IEC 14882:2017**

C++17 更新内容包括:

```txt
(01) UTF-8 字符文字, 折叠表达式 (fold expressions): 用于可变的模板, 内联变量 (inline variables): 允许在头文件中定义变量;
(02) 在 if 和 switch 语句内可以初始化变量;
(03) 结构化绑定 (Structured Binding): for (auto [key,value] : my_map) {…};
(04) 类模板参数规约 (Class Template Argument Deduction): 用 pair p{1, 2.0};
(05) 替代 pair{1, 2.0};; &gt;; static_assert 的文本信息可选;
(06) 删除 trigraphs;
(07) 在模板参数中允许使用 typename (作为替代类);
(08) 来自 braced-init-list 的新规则用于自动推导;
(09) 嵌套命名空间的定义;
(10) 允许命名空间和枚举器的属性;
(11) 新的标准属性: [[fallthrough]], [[maybe_unused]] 和 [[nodiscard]];
(12) 对所有非类型模板参数进行常量评估;
(13) Fold 表达式, 用于可变的模板; A compile-time static if with the form if constexpr (expression);
(14) 结构化的绑定声明, 允许 auto [a, b]=getTwoReturnValues ()。
```

## 测试 C11 标准的支持

使用 _Generic 关键字来判断是否支持 C11。

代码示例:

```cpp
#include <stdio.h>
 
int main() {
    printf("%d\n", _Generic(0, int: 1, default: 0));
    return 0;
}
```

## 测试 C++11 标准的支持

使用了 C++11 的特性, 比如 nullptr 和列表初始化来判断是否支持 C++11。

示例代码:

```cpp
#include <iostream>
 
int main() {
    int x = 10;
    int y = 20;
    auto z = x + y; // C++11 auto keyword
    std::cout << "The sum is: " << z << std::endl;
    int* p = nullptr; // C++11 nullptr
    if (p == nullptr) {
        std::cout << "p is nullptr" << std::endl;
    }
    // C++11 uniform initialization
    int a{5};
    std::vector<int> v{1, 2, 3, 4, 5}; // C++11 list initialization
    return 0;
}
```

## 测试 C++17 标准的支持

示例代码:

```cpp
#include <iostream>
#include <string>
#include <variant>
 
int main() {
    std::variant<int, std::string> v = "Hello, C++17!";
    std::visit([](auto&& arg) std::cout << arg << std::endl; }, v);
    return 0;
}
```

## 总结

以上就是关于 Unix运维 如何测试C11和C++11至C17和C++17标准的支持 的全部内容。

更多内容可以访问我的代码仓库:

https://gitee.com/goufeng928/public

https://github.com/goufeng928/public
